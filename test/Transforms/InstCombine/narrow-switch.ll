; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Vary legal integer types in data layout.
; RUN: opt < %s -instcombine -S -default-data-layout=n32    | FileCheck %s --check-prefix=ALL --check-prefix=CHECK32
; RUN: opt < %s -instcombine -S -default-data-layout=n32:64 | FileCheck %s --check-prefix=ALL --check-prefix=CHECK64

define i32 @positive1(i64 %a) {
; CHECK32-LABEL: @positive1(
; CHECK32:         switch i32
; CHECK32-NEXT:    i32 10, label %return
; CHECK32-NEXT:    i32 100, label %sw.bb1
; CHECK32-NEXT:    i32 1001, label %sw.bb2
; CHECK32-NEXT:    ]
;
; CHECK64-LABEL: @positive1(
; CHECK64:         switch i64
; CHECK64-NEXT:    i64 10, label %return
; CHECK64-NEXT:    i64 100, label %sw.bb1
; CHECK64-NEXT:    i64 1001, label %sw.bb2
; CHECK64-NEXT:    ]
;
entry:
  %and = and i64 %a, 4294967295
  switch i64 %and, label %sw.default [
  i64 10, label %return
  i64 100, label %sw.bb1
  i64 1001, label %sw.bb2
  ]

sw.bb1:
  br label %return

sw.bb2:
  br label %return

sw.default:
  br label %return

return:
  %retval.0 = phi i32 [ 24, %sw.default ], [ 123, %sw.bb2 ], [ 213, %sw.bb1 ], [ 231, %entry ]
  ret i32 %retval.0
}

define i32 @negative1(i64 %a) {
; CHECK32-LABEL: @negative1(
; CHECK32:         switch i32
; CHECK32-NEXT:    i32 -10, label %return
; CHECK32-NEXT:    i32 -100, label %sw.bb1
; CHECK32-NEXT:    i32 -1001, label %sw.bb2
; CHECK32-NEXT:    ]
;
; CHECK64-LABEL: @negative1(
; CHECK64:         switch i64
; CHECK64-NEXT:    i64 -10, label %return
; CHECK64-NEXT:    i64 -100, label %sw.bb1
; CHECK64-NEXT:    i64 -1001, label %sw.bb2
; CHECK64-NEXT:    ]
;
entry:
  %or = or i64 %a, -4294967296
  switch i64 %or, label %sw.default [
  i64 -10, label %return
  i64 -100, label %sw.bb1
  i64 -1001, label %sw.bb2
  ]

sw.bb1:
  br label %return

sw.bb2:
  br label %return

sw.default:
  br label %return

return:
  %retval.0 = phi i32 [ 24, %sw.default ], [ 123, %sw.bb2 ], [ 213, %sw.bb1 ], [ 231, %entry ]
  ret i32 %retval.0
}

; Make sure truncating a constant int larger than 64-bit doesn't trigger an
; assertion.

define i32 @trunc72to68(i72 %a) {
; ALL-LABEL: @trunc72to68(
; ALL:         switch i68
; ALL-NEXT:    i68 10, label %return
; ALL-NEXT:    i68 100, label %sw.bb1
; ALL-NEXT:    i68 1001, label %sw.bb2
; ALL-NEXT:    ]
;
entry:
  %and = and i72 %a, 295147905179352825855
  switch i72 %and, label %sw.default [
  i72 10, label %return
  i72 100, label %sw.bb1
  i72 1001, label %sw.bb2
  ]

sw.bb1:
  br label %return

sw.bb2:
  br label %return

sw.default:
  br label %return

return:
  %retval.0 = phi i32 [ 24, %sw.default ], [ 123, %sw.bb2 ], [ 213, %sw.bb1 ], [ 231, %entry ]
  ret i32 %retval.0
}

; Make sure to avoid assertion crashes and use the type before
; truncation to generate the sub constant expressions that leads
; to the recomputed condition.

define void @trunc64to59(i64 %a) {
; CHECK32-LABEL: @trunc64to59(
; CHECK32:         switch i59
; CHECK32-NEXT:    i59 0, label %sw.bb1
; CHECK32-NEXT:    i59 18717182647723699, label %sw.bb2
; CHECK32-NEXT:    ]
;
; CHECK64-LABEL: @trunc64to59(
; CHECK64:         switch i64
; CHECK64-NEXT:    i64 0, label %sw.bb1
; CHECK64-NEXT:    i64 18717182647723699, label %sw.bb2
; CHECK64-NEXT:    ]
;
entry:
  %tmp0 = and i64 %a, 15
  %tmp1 = mul i64 %tmp0, -6425668444178048401
  %tmp2 = add i64 %tmp1, 5170979678563097242
  %tmp3 = mul i64 %tmp2, 1627972535142754813
  switch i64 %tmp3, label %sw.default [
  i64 847514119312061490, label %sw.bb1
  i64 866231301959785189, label %sw.bb2
  ]

sw.bb1:
  br label %sw.default

sw.bb2:
  br label %sw.default

sw.default:
  ret void
}
